
package WenetSTT_cpp;
use strict; use Cwd 'realpath';  use File::Basename;  use lib dirname(__FILE__);  use SPL::Operator::Instance::OperatorInstance; use SPL::Operator::Instance::Annotation; use SPL::Operator::Instance::Context; use SPL::Operator::Instance::Expression; use SPL::Operator::Instance::ExpressionTree; use SPL::Operator::Instance::ExpressionTreeEvaluator; use SPL::Operator::Instance::ExpressionTreeVisitor; use SPL::Operator::Instance::ExpressionTreeCppGenVisitor; use SPL::Operator::Instance::InputAttribute; use SPL::Operator::Instance::InputPort; use SPL::Operator::Instance::OutputAttribute; use SPL::Operator::Instance::OutputPort; use SPL::Operator::Instance::Parameter; use SPL::Operator::Instance::StateVariable; use SPL::Operator::Instance::TupleValue; use SPL::Operator::Instance::Window; 
sub main::generate($$) {
   my ($xml, $signature) = @_;  
   print "// $$signature\n";
   my $model = SPL::Operator::Instance::OperatorInstance->new($$xml);
   unshift @INC, dirname ($model->getContext()->getOperatorDirectory()) . "/../impl/nl/include";
   $SPL::CodeGenHelper::verboseMode = $model->getContext()->isVerboseModeOn();
   print '/* ', "\n";
   print ' * Generated by Streams Studio: %GENERATED_DATE%', "\n";
   print ' */', "\n";
   print "\n";
   print '#include <SPL/Runtime/Function/SPLFunctions.h>', "\n";
   print '#include <SPL/Runtime/Type/Tuple.h>', "\n";
   print '#include <SPL/Runtime/Operator/OperatorMetrics.h>', "\n";
   print '#include <SPL/Runtime/Common/Metric.h>', "\n";
   print '#include <SPL/Runtime/Serialization/NetworkByteBuffer.h>', "\n";
   print "\n";
   print '#include "WenetSTTImpl.hpp"', "\n";
   print "\n";
   SPL::CodeGen::headerPrologue($model);
   print "\n";
   print "\n";
   print 'class MY_OPERATOR : public MY_BASE_OPERATOR, public wenet_streams::TranscriptionCallback {', "\n";
   print 'public:', "\n";
   print '    MY_OPERATOR();', "\n";
   print '    ~MY_OPERATOR();', "\n";
   print '    ', "\n";
   print '    void setup();', "\n";
   print '    void process(Tuple const & tuple, uint32_t port);', "\n";
   print '    void process(Punctuation const & punct, uint32_t port);', "\n";
   print '    void allPortsReady();', "\n";
   print '    void shutdown();', "\n";
   print '    ', "\n";
   print '    // Implementation of TranscriptionCallback interface', "\n";
   print '    void onTranscriptionResult(const wenet_streams::TranscriptionResult& result) override;', "\n";
   print '    void onError(const std::string& errorMessage) override;', "\n";
   print '    ', "\n";
   print 'private:', "\n";
   print '    // Audio conversion utility', "\n";
   print '    void convertBlobToSamples(const SPL::blob& audioBlob, std::vector<int16_t>& samples);', "\n";
   print '    ', "\n";
   print '    // WeNet implementation', "\n";
   print '    std::unique_ptr<wenet_streams::WenetSTTImpl> wenetSTT_;', "\n";
   print '    ', "\n";
   print '    // Parameters', "\n";
   print '    std::string modelPath_;', "\n";
   print '    int32_t sampleRate_;', "\n";
   print '    bool partialResultsEnabled_;', "\n";
   print '    double maxLatency_;', "\n";
   print '    bool vad_;', "\n";
   print '    double vadSilenceThreshold_;', "\n";
   print '    double vadSpeechThreshold_;', "\n";
   print '    double maxChunkDuration_;', "\n";
   print '    ', "\n";
   print '    // Metrics', "\n";
   print '    Metric* audioChunksReceived_;', "\n";
   print '    Metric* resultsEmitted_;', "\n";
   print '    Metric* finalResultsEmitted_;', "\n";
   print '    Metric* partialResultsEmitted_;', "\n";
   print '    Metric* processingTime_;', "\n";
   print '    Metric* errorCount_;', "\n";
   print '};', "\n";
   print "\n";
   print 'MY_OPERATOR_SCOPE::MY_OPERATOR::MY_OPERATOR()', "\n";
   print '{', "\n";
   print '    // Initialize metrics', "\n";
   print '    OperatorMetrics& metrics = getContext().getMetrics();', "\n";
   print '    audioChunksReceived_ = &metrics.createCustomMetric("audioChunksReceived", "Number of audio chunks received", Metric::Counter);', "\n";
   print '    resultsEmitted_ = &metrics.createCustomMetric("resultsEmitted", "Total number of results emitted", Metric::Counter);', "\n";
   print '    finalResultsEmitted_ = &metrics.createCustomMetric("finalResultsEmitted", "Number of final results emitted", Metric::Counter);', "\n";
   print '    partialResultsEmitted_ = &metrics.createCustomMetric("partialResultsEmitted", "Number of partial results emitted", Metric::Counter);', "\n";
   print '    processingTime_ = &metrics.createCustomMetric("processingTime", "Average processing time in milliseconds", Metric::Gauge);', "\n";
   print '    errorCount_ = &metrics.createCustomMetric("errorCount", "Number of errors encountered", Metric::Counter);', "\n";
   print '}', "\n";
   print "\n";
   print 'MY_OPERATOR_SCOPE::MY_OPERATOR::~MY_OPERATOR()', "\n";
   print '{', "\n";
   print '    // Clean up resources', "\n";
   print '    wenetSTT_.reset();', "\n";
   print '}', "\n";
   print "\n";
   print 'void MY_OPERATOR_SCOPE::MY_OPERATOR::setup()', "\n";
   print '{', "\n";
   print '    // Get configuration parameters', "\n";
   print '    ';
    if (defined $model->getParameterByName("modelPath")) { 
   print "\n";
   print '    modelPath_ = ';
   print $model->getParameterByName("modelPath")->getValueAt(0)->getCppExpression();
   print ';', "\n";
   print '    ';
    } 
   print "\n";
   print '    ', "\n";
   print '    ';
    if (defined $model->getParameterByName("sampleRate")) { 
   print "\n";
   print '    sampleRate_ = ';
   print $model->getParameterByName("sampleRate")->getValueAt(0)->getCppExpression();
   print ';', "\n";
   print '    ';
    } else { 
   print "\n";
   print '    sampleRate_ = 16000;', "\n";
   print '    ';
    } 
   print "\n";
   print '    ', "\n";
   print '    ';
    if (defined $model->getParameterByName("partialResultsEnabled")) { 
   print "\n";
   print '    partialResultsEnabled_ = ';
   print $model->getParameterByName("partialResultsEnabled")->getValueAt(0)->getCppExpression();
   print ';', "\n";
   print '    ';
    } else { 
   print "\n";
   print '    partialResultsEnabled_ = true;', "\n";
   print '    ';
    } 
   print "\n";
   print '    ', "\n";
   print '    ';
    if (defined $model->getParameterByName("maxLatency")) { 
   print "\n";
   print '    maxLatency_ = ';
   print $model->getParameterByName("maxLatency")->getValueAt(0)->getCppExpression();
   print ';', "\n";
   print '    ';
    } else { 
   print "\n";
   print '    maxLatency_ = 0.3;', "\n";
   print '    ';
    } 
   print "\n";
   print '    ', "\n";
   print '    ';
    if (defined $model->getParameterByName("vad")) { 
   print "\n";
   print '    vad_ = ';
   print $model->getParameterByName("vad")->getValueAt(0)->getCppExpression();
   print ';', "\n";
   print '    ';
    } else { 
   print "\n";
   print '    vad_ = true;', "\n";
   print '    ';
    } 
   print "\n";
   print '    ', "\n";
   print '    ';
    if (defined $model->getParameterByName("vadSilenceThreshold")) { 
   print "\n";
   print '    vadSilenceThreshold_ = ';
   print $model->getParameterByName("vadSilenceThreshold")->getValueAt(0)->getCppExpression();
   print ';', "\n";
   print '    ';
    } else { 
   print "\n";
   print '    vadSilenceThreshold_ = -40.0;', "\n";
   print '    ';
    } 
   print "\n";
   print '    ', "\n";
   print '    ';
    if (defined $model->getParameterByName("vadSpeechThreshold")) { 
   print "\n";
   print '    vadSpeechThreshold_ = ';
   print $model->getParameterByName("vadSpeechThreshold")->getValueAt(0)->getCppExpression();
   print ';', "\n";
   print '    ';
    } else { 
   print "\n";
   print '    vadSpeechThreshold_ = -10.0;', "\n";
   print '    ';
    } 
   print "\n";
   print '    ', "\n";
   print '    ';
    if (defined $model->getParameterByName("maxChunkDuration")) { 
   print "\n";
   print '    maxChunkDuration_ = ';
   print $model->getParameterByName("maxChunkDuration")->getValueAt(0)->getCppExpression();
   print ';', "\n";
   print '    ';
    } else { 
   print "\n";
   print '    maxChunkDuration_ = 3.0;', "\n";
   print '    ';
    } 
   print "\n";
   print '    ', "\n";
   print '    // Configure and initialize the WeNet STT engine', "\n";
   print '    wenet_streams::WeNetConfig config;', "\n";
   print '    config.modelPath = modelPath_;', "\n";
   print '    config.sampleRate = sampleRate_;', "\n";
   print '    config.partialResultsEnabled = partialResultsEnabled_;', "\n";
   print '    config.maxLatency = maxLatency_;', "\n";
   print '    config.vadEnabled = vad_;', "\n";
   print '    config.vadSilenceThreshold = vadSilenceThreshold_;', "\n";
   print '    config.vadSpeechThreshold = vadSpeechThreshold_;', "\n";
   print '    config.maxChunkDuration = maxChunkDuration_;', "\n";
   print '    ', "\n";
   print '    // Create the WeNet STT implementation', "\n";
   print '    wenetSTT_ = std::make_unique<wenet_streams::WenetSTTImpl>(config, this);', "\n";
   print '    ', "\n";
   print '    // Initialize the engine', "\n";
   print '    if (!wenetSTT_->initialize()) {', "\n";
   print '        SPLTRACEMSG(L_ERROR, "Failed to initialize WeNet STT engine", "WenetSTT");', "\n";
   print '        throw std::runtime_error("Failed to initialize WeNet STT engine");', "\n";
   print '    }', "\n";
   print '    ', "\n";
   print '    SPLTRACEMSG(L_INFO, "WeNet STT operator successfully initialized", "WenetSTT");', "\n";
   print '}', "\n";
   print "\n";
   print 'void MY_OPERATOR_SCOPE::MY_OPERATOR::process(Tuple const & tuple, uint32_t port)', "\n";
   print '{', "\n";
   print '    // Increment the received chunks counter', "\n";
   print '    audioChunksReceived_->incrementValue();', "\n";
   print '    ', "\n";
   print '    // Extract audio data and timestamp from the tuple', "\n";
   print '    ';
    
       my $inputPort = $model->getInputPortAt(0);
       my $audioDataAttr = undef;
       my $timestampAttr = undef;
       
       # Find the audio data and timestamp attributes in the input tuple
       foreach my $attr (@{$inputPort->getAttributes()}) {
           my $name = $attr->getName();
           my $type = $attr->getType()->getCppType();
           
           if ($type eq "SPL::blob") {
               $audioDataAttr = $attr;
           } elsif ($type eq "uint64_t") {
               $timestampAttr = $attr;
           }
       }
       
       if (!defined $audioDataAttr) {
           SPL::CodeGen::exitln("ERROR: Input port must have a blob attribute for audio data");
       }
       
   print "\n";
   print '    ', "\n";
   print '    // Get audio data from tuple', "\n";
   print '    const SPL::blob& audioBlob = tuple.get_';
   print $audioDataAttr->getName();
   print '();', "\n";
   print '    ', "\n";
   print '    // Get timestamp from tuple (or use current time if not available)', "\n";
   print '    uint64_t timestamp = 0;', "\n";
   print '    ';
    if (defined $timestampAttr) { 
   print "\n";
   print '    timestamp = tuple.get_';
   print $timestampAttr->getName();
   print '();', "\n";
   print '    ';
    } else { 
   print "\n";
   print '    timestamp = std::chrono::duration_cast<std::chrono::milliseconds>(', "\n";
   print '                   std::chrono::system_clock::now().time_since_epoch()).count();', "\n";
   print '    ';
    } 
   print "\n";
   print '    ', "\n";
   print '    // Convert blob to audio samples', "\n";
   print '    std::vector<int16_t> samples;', "\n";
   print '    convertBlobToSamples(audioBlob, samples);', "\n";
   print '    ', "\n";
   print '    // Track processing start time', "\n";
   print '    auto startTime = std::chrono::high_resolution_clock::now();', "\n";
   print '    ', "\n";
   print '    // Process the audio chunk', "\n";
   print '    wenet_streams::AudioChunk chunk(samples, timestamp);', "\n";
   print '    wenetSTT_->processAudioChunk(chunk);', "\n";
   print '    ', "\n";
   print '    // Track processing end time', "\n";
   print '    auto endTime = std::chrono::high_resolution_clock::now();', "\n";
   print '    auto duration = std::chrono::duration_cast<std::chrono::milliseconds>(endTime - startTime).count();', "\n";
   print '    ', "\n";
   print '    // Update processing time metric', "\n";
   print '    processingTime_->setValue(duration);', "\n";
   print '}', "\n";
   print "\n";
   print 'void MY_OPERATOR_SCOPE::MY_OPERATOR::process(Punctuation const & punct, uint32_t port)', "\n";
   print '{', "\n";
   print '    // If we receive a window punctuation, flush the STT engine', "\n";
   print '    if (punct == Punctuation::WindowMarker) {', "\n";
   print '        wenetSTT_->flush();', "\n";
   print '    }', "\n";
   print '    ', "\n";
   print '    // Forward the punctuation', "\n";
   print '    submit(punct, 0);', "\n";
   print '}', "\n";
   print "\n";
   print 'void MY_OPERATOR_SCOPE::MY_OPERATOR::allPortsReady()', "\n";
   print '{', "\n";
   print '    // This method is called when all ports are ready to process data', "\n";
   print '}', "\n";
   print "\n";
   print 'void MY_OPERATOR_SCOPE::MY_OPERATOR::shutdown()', "\n";
   print '{', "\n";
   print '    // Flush any pending results', "\n";
   print '    wenetSTT_->flush();', "\n";
   print '}', "\n";
   print "\n";
   print 'void MY_OPERATOR_SCOPE::MY_OPERATOR::onTranscriptionResult(const wenet_streams::TranscriptionResult& result)', "\n";
   print '{', "\n";
   print '    // Create and submit output tuple', "\n";
   print '    ';
       my $outputPort = $model->getOutputPortAt(0);
       my $textAttr = undef;
       my $isFinalAttr = undef;
       my $confidenceAttr = undef;
       
       # Find the text, isFinal, and confidence attributes in the output tuple
       foreach my $attr (@{$outputPort->getAttributes()}) {
           my $name = $attr->getName();
           my $type = $attr->getType()->getCppType();
           
           if ($type eq "SPL::rstring") {
               $textAttr = $attr;
           } elsif ($type eq "boolean") {
               $isFinalAttr = $attr;
           } elsif ($type eq "SPL::float64") {
               $confidenceAttr = $attr;
           }
       }
       
   print "\n";
   print '    ', "\n";
   print '    OPort0Type outTuple;', "\n";
   print '    ', "\n";
   print '    ';
    if (defined $textAttr) { 
   print "\n";
   print '    outTuple.set_';
   print $textAttr->getName();
   print '(result.text);', "\n";
   print '    ';
    } 
   print "\n";
   print '    ', "\n";
   print '    ';
    if (defined $isFinalAttr) { 
   print "\n";
   print '    outTuple.set_';
   print $isFinalAttr->getName();
   print '(result.isFinal);', "\n";
   print '    ';
    } 
   print "\n";
   print '    ', "\n";
   print '    ';
    if (defined $confidenceAttr) { 
   print "\n";
   print '    outTuple.set_';
   print $confidenceAttr->getName();
   print '(result.confidence);', "\n";
   print '    ';
    } 
   print "\n";
   print '    ', "\n";
   print '    // Update metrics', "\n";
   print '    resultsEmitted_->incrementValue();', "\n";
   print '    if (result.isFinal) {', "\n";
   print '        finalResultsEmitted_->incrementValue();', "\n";
   print '    } else {', "\n";
   print '        partialResultsEmitted_->incrementValue();', "\n";
   print '    }', "\n";
   print '    ', "\n";
   print '    // Submit the output tuple', "\n";
   print '    submit(outTuple, 0);', "\n";
   print '}', "\n";
   print "\n";
   print 'void MY_OPERATOR_SCOPE::MY_OPERATOR::onError(const std::string& errorMessage)', "\n";
   print '{', "\n";
   print '    // Log the error', "\n";
   print '    SPLTRACEMSG(L_ERROR, errorMessage, "WenetSTT");', "\n";
   print '    ', "\n";
   print '    // Increment error count', "\n";
   print '    errorCount_->incrementValue();', "\n";
   print '}', "\n";
   print "\n";
   print 'void MY_OPERATOR_SCOPE::MY_OPERATOR::convertBlobToSamples(const SPL::blob& audioBlob, std::vector<int16_t>& samples)', "\n";
   print '{', "\n";
   print '    // Get blob data', "\n";
   print '    const unsigned char* data = audioBlob.getData();', "\n";
   print '    uint64_t size = audioBlob.getSize();', "\n";
   print '    ', "\n";
   print '    // Clear the samples vector', "\n";
   print '    samples.clear();', "\n";
   print '    ', "\n";
   print '    // Convert the blob to audio samples (assuming 16-bit PCM format)', "\n";
   print '    if (size < 2 || size % 2 != 0) {', "\n";
   print '        SPLTRACEMSG(L_WARN, "Invalid audio blob size: " + SPL::Functions::String::formatNumber(size), "WenetSTT");', "\n";
   print '        return;', "\n";
   print '    }', "\n";
   print '    ', "\n";
   print '    // Resize the vector to hold the samples', "\n";
   print '    samples.resize(size / 2);', "\n";
   print '    ', "\n";
   print '    // Convert bytes to int16_t samples', "\n";
   print '    for (uint64_t i = 0; i < size; i += 2) {', "\n";
   print '        int16_t sample = static_cast<int16_t>((data[i+1] << 8) | data[i]);', "\n";
   print '        samples[i/2] = sample;', "\n";
   print '    }', "\n";
   print '}', "\n";
   print "\n";
   SPL::CodeGen::implementationEpilogue($model);
   print "\n";
   CORE::exit $SPL::CodeGen::USER_ERROR if ($SPL::CodeGen::sawError);
}
1;
