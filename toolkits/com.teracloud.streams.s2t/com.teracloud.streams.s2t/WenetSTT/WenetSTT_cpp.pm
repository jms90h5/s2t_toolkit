
package WenetSTT_cpp;
use strict; use Cwd 'realpath';  use File::Basename;  use lib dirname(__FILE__);  use SPL::Operator::Instance::OperatorInstance; use SPL::Operator::Instance::Annotation; use SPL::Operator::Instance::Context; use SPL::Operator::Instance::Expression; use SPL::Operator::Instance::ExpressionTree; use SPL::Operator::Instance::ExpressionTreeEvaluator; use SPL::Operator::Instance::ExpressionTreeVisitor; use SPL::Operator::Instance::ExpressionTreeCppGenVisitor; use SPL::Operator::Instance::InputAttribute; use SPL::Operator::Instance::InputPort; use SPL::Operator::Instance::OutputAttribute; use SPL::Operator::Instance::OutputPort; use SPL::Operator::Instance::Parameter; use SPL::Operator::Instance::StateVariable; use SPL::Operator::Instance::TupleValue; use SPL::Operator::Instance::Window; 
sub main::generate($$) {
   my ($xml, $signature) = @_;  
   print "// $$signature\n";
   my $model = SPL::Operator::Instance::OperatorInstance->new($$xml);
   unshift @INC, dirname ($model->getContext()->getOperatorDirectory()) . "/../impl/nl/include";
   $SPL::CodeGenHelper::verboseMode = $model->getContext()->isVerboseModeOn();
   print '/*', "\n";
   print ' * WenetSTT operator implementation', "\n";
   print ' */', "\n";
   print "\n";
   SPL::CodeGen::implementationPrologue($model);
   print "\n";
   print "\n";
       my $modelPath = $model->getParameterByName("modelPath")->getValueAt(0)->getCppExpression();
       
       my $sampleRate = $model->getParameterByName("sampleRate");
       $sampleRate = $sampleRate ? $sampleRate->getValueAt(0)->getCppExpression() : "16000";
       
       my $chunkSize = $model->getParameterByName("chunkSize");
       $chunkSize = $chunkSize ? $chunkSize->getValueAt(0)->getCppExpression() : "16";
       
       my $nbest = $model->getParameterByName("nbest");
       $nbest = $nbest ? $nbest->getValueAt(0)->getCppExpression() : "1";
       
       my $numThreads = $model->getParameterByName("numThreads");
       $numThreads = $numThreads ? $numThreads->getValueAt(0)->getCppExpression() : "1";
   print "\n";
   print "\n";
   print '// Implementation code starts here', "\n";
   print '#include <SPL/Runtime/Common/ApplicationRuntimeMessage.h>', "\n";
   print '#include <SPL/Runtime/Utility/LogTraceMessage.h>', "\n";
   print '#include <iostream>', "\n";
   print '#include <vector>', "\n";
   print "\n";
   print 'using namespace SPL;', "\n";
   print 'using namespace std;', "\n";
   print "\n";
   print '// Using the SPL-generated namespace and class names', "\n";
   print "\n";
   print 'MY_OPERATOR_SCOPE::MY_OPERATOR::MY_OPERATOR() ', "\n";
   print '    : initialized_(false)', "\n";
   print '    , audio_timestamp_ms_(0)', "\n";
   print '    , total_samples_processed_(0) {', "\n";
   print '    ', "\n";
   print '    SPLAPPTRC(L_DEBUG, "WenetSTT operator constructor", "WenetSTT");', "\n";
   print '}', "\n";
   print "\n";
   print 'MY_OPERATOR_SCOPE::MY_OPERATOR::~MY_OPERATOR() {', "\n";
   print '    SPLAPPTRC(L_DEBUG, "WenetSTT operator destructor", "WenetSTT");', "\n";
   print '}', "\n";
   print "\n";
   print 'void MY_OPERATOR_SCOPE::MY_OPERATOR::initialize() {', "\n";
   print '    if (initialized_) return;', "\n";
   print '    ', "\n";
   print '    try {', "\n";
   print '        // Configure WeNet implementation', "\n";
   print '        config_.model_dir = ';
   print $modelPath;
   print ';', "\n";
   print '        config_.sample_rate = ';
   print $sampleRate;
   print ';', "\n";
   print '        config_.chunk_size = ';
   print $chunkSize;
   print ';', "\n";
   print '        config_.nbest = ';
   print $nbest;
   print ';', "\n";
   print '        config_.num_threads = ';
   print $numThreads;
   print ';', "\n";
   print '        config_.enable_timestamp = false;', "\n";
   print '        ', "\n";
   print '        SPLAPPTRC(L_INFO, "Initializing WenetSTT with model: " + config_.model_dir, "WenetSTT");', "\n";
   print '        ', "\n";
   print '        // Create implementation', "\n";
   print '        wenet_impl_ = std::make_unique<wenet_streams::WenetSTTWrapper>(config_);', "\n";
   print '        ', "\n";
   print '        // Initialize', "\n";
   print '        if (!wenet_impl_->initialize()) {', "\n";
   print '            SPLAPPTRC(L_ERROR, "Failed to initialize WenetSTT", "WenetSTT");', "\n";
   print '            throw std::runtime_error("WenetSTT initialization failed");', "\n";
   print '        }', "\n";
   print '        ', "\n";
   print '        initialized_ = true;', "\n";
   print '        SPLAPPTRC(L_INFO, "WenetSTT initialized successfully", "WenetSTT");', "\n";
   print '        ', "\n";
   print '    } catch (const std::exception& e) {', "\n";
   print '        SPLAPPTRC(L_ERROR, "Exception during initialization: " + string(e.what()), "WenetSTT");', "\n";
   print '        throw;', "\n";
   print '    }', "\n";
   print '}', "\n";
   print "\n";
   print 'void MY_OPERATOR_SCOPE::MY_OPERATOR::process(Tuple const & tuple, uint32_t port) {', "\n";
   print '    // Initialize on first tuple', "\n";
   print '    if (!initialized_) {', "\n";
   print '        initialize();', "\n";
   print '    }', "\n";
   print '    ', "\n";
   print '    AutoPortMutex apm(_mutex, *this);', "\n";
   print '    ', "\n";
   print '    const IPort0Type& iport = static_cast<const IPort0Type&>(tuple);', "\n";
   print '    ', "\n";
   print '    // Get audio data', "\n";
   print '    // Note: This assumes the input has an attribute that is a blob', "\n";
   print '    // In this sample it\'s named \'audioChunk\'', "\n";
   print '    processAudioData(iport.get_audioChunk());', "\n";
   print '    ', "\n";
   print '    // Get timestamp', "\n";
   print '    audio_timestamp_ms_ = iport.get_audioTimestamp();', "\n";
   print '}', "\n";
   print "\n";
   print 'void MY_OPERATOR_SCOPE::MY_OPERATOR::processAudioData(const SPL::blob& audio_blob) {', "\n";
   print '    // Get audio samples', "\n";
   print '    const int16_t* samples = reinterpret_cast<const int16_t*>(audio_blob.getData());', "\n";
   print '    size_t num_samples = audio_blob.getSize() / sizeof(int16_t);', "\n";
   print '    ', "\n";
   print '    if (num_samples == 0) return;', "\n";
   print '    ', "\n";
   print '    // Process with WeNet implementation', "\n";
   print '    auto result = wenet_impl_->processAudioChunk(samples, num_samples, audio_timestamp_ms_);', "\n";
   print '    ', "\n";
   print '    // Update stats', "\n";
   print '    total_samples_processed_ += num_samples;', "\n";
   print '    audio_timestamp_ms_ += (num_samples * 1000) / config_.sample_rate;', "\n";
   print '    ', "\n";
   print '    // Submit result if we have text', "\n";
   print '    if (!result.text.empty()) {', "\n";
   print '        submitResult(result);', "\n";
   print '    }', "\n";
   print '    ', "\n";
   print '    // Log performance periodically', "\n";
   print '    if (total_samples_processed_ % (config_.sample_rate * 10) == 0) {', "\n";
   print '        auto stats = wenet_impl_->getStats();', "\n";
   print '        SPLAPPTRC(L_INFO, ', "\n";
   print '            "Processed " + to_string(total_samples_processed_ / config_.sample_rate) + ', "\n";
   print '            " seconds, RTF: " + to_string(stats.real_time_factor), ', "\n";
   print '            "WenetSTT");', "\n";
   print '    }', "\n";
   print '}', "\n";
   print "\n";
   print 'void MY_OPERATOR_SCOPE::MY_OPERATOR::submitResult(const wenet_streams::WenetSTTWrapper::TranscriptionResult& result) {', "\n";
   print '    // Create output tuple', "\n";
   print '    OPort0Type otuple;', "\n";
   print '    ', "\n";
   print '    // Set attributes', "\n";
   print '    otuple.set_text(result.text);', "\n";
   print '    otuple.set_isFinal(result.is_final);', "\n";
   print '    otuple.set_confidence(result.confidence);', "\n";
   print '    ', "\n";
   print '    // Submit the tuple', "\n";
   print '    submit(otuple, 0);', "\n";
   print '    ', "\n";
   print '    SPLAPPTRC(L_DEBUG, ', "\n";
   print '        "Submitted: " + result.text + ', "\n";
   print '        " (final=" + to_string(result.is_final) + ', "\n";
   print '        ", latency=" + to_string(result.latency_ms) + "ms)", ', "\n";
   print '        "WenetSTT");', "\n";
   print '}', "\n";
   print "\n";
   print 'void MY_OPERATOR_SCOPE::MY_OPERATOR::process(Punctuation const & punct, uint32_t port) {', "\n";
   print '    if (punct == Punctuation::FinalMarker) {', "\n";
   print '        // Reset the decoder on final punctuation', "\n";
   print '        if (wenet_impl_) {', "\n";
   print '            wenet_impl_->reset();', "\n";
   print '            SPLAPPTRC(L_DEBUG, "Reset decoder on final punctuation", "WenetSTT");', "\n";
   print '        }', "\n";
   print '    }', "\n";
   print '    ', "\n";
   print '    // Forward punctuation', "\n";
   print '    submit(punct, 0);', "\n";
   print '}', "\n";
   print "\n";
   print '// End of implementation', "\n";
   print "\n";
   SPL::CodeGen::implementationEpilogue($model);
   print "\n";
   CORE::exit $SPL::CodeGen::USER_ERROR if ($SPL::CodeGen::sawError);
}
1;
