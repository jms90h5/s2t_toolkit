/* 
 * Generated by Streams Studio: %GENERATED_DATE%
 */

#include <SPL/Runtime/Function/SPLFunctions.h>
#include <SPL/Runtime/Type/Tuple.h>
#include <SPL/Runtime/Operator/OperatorMetrics.h>
#include <SPL/Runtime/Common/Metric.h>
#include <SPL/Runtime/Serialization/NetworkByteBuffer.h>

#include "WenetSTTImpl.hpp"

<%SPL::CodeGen::headerPrologue($model);%>

class MY_OPERATOR : public MY_BASE_OPERATOR, public wenet_streams::TranscriptionCallback {
public:
    MY_OPERATOR();
    ~MY_OPERATOR();
    
    void setup();
    void process(Tuple const & tuple, uint32_t port);
    void process(Punctuation const & punct, uint32_t port);
    void allPortsReady();
    void shutdown();
    
    // Implementation of TranscriptionCallback interface
    void onTranscriptionResult(const wenet_streams::TranscriptionResult& result) override;
    void onError(const std::string& errorMessage) override;
    
private:
    // Audio conversion utility
    void convertBlobToSamples(const SPL::blob& audioBlob, std::vector<int16_t>& samples);
    
    // WeNet implementation
    std::unique_ptr<wenet_streams::WenetSTTImpl> wenetSTT_;
    
    // Parameters
    std::string modelPath_;
    int32_t sampleRate_;
    bool partialResultsEnabled_;
    double maxLatency_;
    bool vad_;
    double vadSilenceThreshold_;
    double vadSpeechThreshold_;
    double maxChunkDuration_;
    
    // Metrics
    Metric* audioChunksReceived_;
    Metric* resultsEmitted_;
    Metric* finalResultsEmitted_;
    Metric* partialResultsEmitted_;
    Metric* processingTime_;
    Metric* errorCount_;
};

MY_OPERATOR::MY_OPERATOR()
{
    // Initialize metrics
    OperatorMetrics& metrics = getContext().getMetrics();
    audioChunksReceived_ = &metrics.createCustomMetric("audioChunksReceived", "Number of audio chunks received", Metric::Counter);
    resultsEmitted_ = &metrics.createCustomMetric("resultsEmitted", "Total number of results emitted", Metric::Counter);
    finalResultsEmitted_ = &metrics.createCustomMetric("finalResultsEmitted", "Number of final results emitted", Metric::Counter);
    partialResultsEmitted_ = &metrics.createCustomMetric("partialResultsEmitted", "Number of partial results emitted", Metric::Counter);
    processingTime_ = &metrics.createCustomMetric("processingTime", "Average processing time in milliseconds", Metric::Gauge);
    errorCount_ = &metrics.createCustomMetric("errorCount", "Number of errors encountered", Metric::Counter);
}

MY_OPERATOR::~MY_OPERATOR()
{
    // Clean up resources
    wenetSTT_.reset();
}

void MY_OPERATOR::setup()
{
    // Get configuration parameters
    <% if (defined $model->getParameterByName("modelPath")) { %>
    modelPath_ = <%=$model->getParameterByName("modelPath")->getValueAt(0)->getCppExpression()%>;
    <% } %>
    
    <% if (defined $model->getParameterByName("sampleRate")) { %>
    sampleRate_ = <%=$model->getParameterByName("sampleRate")->getValueAt(0)->getCppExpression()%>;
    <% } else { %>
    sampleRate_ = 16000;
    <% } %>
    
    <% if (defined $model->getParameterByName("partialResultsEnabled")) { %>
    partialResultsEnabled_ = <%=$model->getParameterByName("partialResultsEnabled")->getValueAt(0)->getCppExpression()%>;
    <% } else { %>
    partialResultsEnabled_ = true;
    <% } %>
    
    <% if (defined $model->getParameterByName("maxLatency")) { %>
    maxLatency_ = <%=$model->getParameterByName("maxLatency")->getValueAt(0)->getCppExpression()%>;
    <% } else { %>
    maxLatency_ = 0.3;
    <% } %>
    
    <% if (defined $model->getParameterByName("vad")) { %>
    vad_ = <%=$model->getParameterByName("vad")->getValueAt(0)->getCppExpression()%>;
    <% } else { %>
    vad_ = true;
    <% } %>
    
    <% if (defined $model->getParameterByName("vadSilenceThreshold")) { %>
    vadSilenceThreshold_ = <%=$model->getParameterByName("vadSilenceThreshold")->getValueAt(0)->getCppExpression()%>;
    <% } else { %>
    vadSilenceThreshold_ = -40.0;
    <% } %>
    
    <% if (defined $model->getParameterByName("vadSpeechThreshold")) { %>
    vadSpeechThreshold_ = <%=$model->getParameterByName("vadSpeechThreshold")->getValueAt(0)->getCppExpression()%>;
    <% } else { %>
    vadSpeechThreshold_ = -10.0;
    <% } %>
    
    <% if (defined $model->getParameterByName("maxChunkDuration")) { %>
    maxChunkDuration_ = <%=$model->getParameterByName("maxChunkDuration")->getValueAt(0)->getCppExpression()%>;
    <% } else { %>
    maxChunkDuration_ = 3.0;
    <% } %>
    
    // Configure and initialize the WeNet STT engine
    wenet_streams::WeNetConfig config;
    config.modelPath = modelPath_;
    config.sampleRate = sampleRate_;
    config.partialResultsEnabled = partialResultsEnabled_;
    config.maxLatency = maxLatency_;
    config.vadEnabled = vad_;
    config.vadSilenceThreshold = vadSilenceThreshold_;
    config.vadSpeechThreshold = vadSpeechThreshold_;
    config.maxChunkDuration = maxChunkDuration_;
    
    // Create the WeNet STT implementation
    wenetSTT_ = std::make_unique<wenet_streams::WenetSTTImpl>(config, this);
    
    // Initialize the engine
    if (!wenetSTT_->initialize()) {
        SPLTRACEMSG(L_ERROR, "Failed to initialize WeNet STT engine", "WenetSTT");
        throw std::runtime_error("Failed to initialize WeNet STT engine");
    }
    
    SPLTRACEMSG(L_INFO, "WeNet STT operator successfully initialized", "WenetSTT");
}

void MY_OPERATOR::process(Tuple const & tuple, uint32_t port)
{
    // Increment the received chunks counter
    audioChunksReceived_->incrementValue();
    
    // Extract audio data and timestamp from the tuple
    <% 
    my $inputPort = $model->getInputPortAt(0);
    my $audioDataAttr = undef;
    my $timestampAttr = undef;
    
    # Find the audio data and timestamp attributes in the input tuple
    foreach my $attr (@{$inputPort->getAttributes()}) {
        my $name = $attr->getName();
        my $type = $attr->getType()->getCppType();
        
        if ($type eq "SPL::blob") {
            $audioDataAttr = $attr;
        } elsif ($type eq "uint64_t") {
            $timestampAttr = $attr;
        }
    }
    
    if (!defined $audioDataAttr) {
        SPL::CodeGen::exitln("ERROR: Input port must have a blob attribute for audio data");
    }
    %>
    
    // Get audio data from tuple
    const SPL::blob& audioBlob = tuple.get_<%=$audioDataAttr->getName()%>();
    
    // Get timestamp from tuple (or use current time if not available)
    uint64_t timestamp = 0;
    <% if (defined $timestampAttr) { %>
    timestamp = tuple.get_<%=$timestampAttr->getName()%>();
    <% } else { %>
    timestamp = std::chrono::duration_cast<std::chrono::milliseconds>(
                   std::chrono::system_clock::now().time_since_epoch()).count();
    <% } %>
    
    // Convert blob to audio samples
    std::vector<int16_t> samples;
    convertBlobToSamples(audioBlob, samples);
    
    // Track processing start time
    auto startTime = std::chrono::high_resolution_clock::now();
    
    // Process the audio chunk
    wenet_streams::AudioChunk chunk(samples, timestamp);
    wenetSTT_->processAudioChunk(chunk);
    
    // Track processing end time
    auto endTime = std::chrono::high_resolution_clock::now();
    auto duration = std::chrono::duration_cast<std::chrono::milliseconds>(endTime - startTime).count();
    
    // Update processing time metric
    processingTime_->setValue(duration);
}

void MY_OPERATOR::process(Punctuation const & punct, uint32_t port)
{
    // If we receive a window punctuation, flush the STT engine
    if (punct == Punctuation::WindowMarker) {
        wenetSTT_->flush();
    }
    
    // Forward the punctuation
    submit(punct, 0);
}

void MY_OPERATOR::allPortsReady()
{
    // This method is called when all ports are ready to process data
}

void MY_OPERATOR::shutdown()
{
    // Flush any pending results
    wenetSTT_->flush();
}

void MY_OPERATOR::onTranscriptionResult(const wenet_streams::TranscriptionResult& result)
{
    // Create and submit output tuple
    <%
    my $outputPort = $model->getOutputPortAt(0);
    my $textAttr = undef;
    my $isFinalAttr = undef;
    my $confidenceAttr = undef;
    
    # Find the text, isFinal, and confidence attributes in the output tuple
    foreach my $attr (@{$outputPort->getAttributes()}) {
        my $name = $attr->getName();
        my $type = $attr->getType()->getCppType();
        
        if ($type eq "SPL::rstring") {
            $textAttr = $attr;
        } elsif ($type eq "boolean") {
            $isFinalAttr = $attr;
        } elsif ($type eq "SPL::float64") {
            $confidenceAttr = $attr;
        }
    }
    %>
    
    OPort0Type outTuple;
    
    <% if (defined $textAttr) { %>
    outTuple.set_<%=$textAttr->getName()%>(result.text);
    <% } %>
    
    <% if (defined $isFinalAttr) { %>
    outTuple.set_<%=$isFinalAttr->getName()%>(result.isFinal);
    <% } %>
    
    <% if (defined $confidenceAttr) { %>
    outTuple.set_<%=$confidenceAttr->getName()%>(result.confidence);
    <% } %>
    
    // Update metrics
    resultsEmitted_->incrementValue();
    if (result.isFinal) {
        finalResultsEmitted_->incrementValue();
    } else {
        partialResultsEmitted_->incrementValue();
    }
    
    // Submit the output tuple
    submit(outTuple, 0);
}

void MY_OPERATOR::onError(const std::string& errorMessage)
{
    // Log the error
    SPLTRACEMSG(L_ERROR, errorMessage, "WenetSTT");
    
    // Increment error count
    errorCount_->incrementValue();
}

void MY_OPERATOR::convertBlobToSamples(const SPL::blob& audioBlob, std::vector<int16_t>& samples)
{
    // Get blob data
    const unsigned char* data = audioBlob.getData();
    uint64_t size = audioBlob.getSize();
    
    // Clear the samples vector
    samples.clear();
    
    // Convert the blob to audio samples (assuming 16-bit PCM format)
    if (size < 2 || size % 2 != 0) {
        SPLTRACEMSG(L_WARN, "Invalid audio blob size: " + SPL::Functions::String::formatNumber(size), "WenetSTT");
        return;
    }
    
    // Resize the vector to hold the samples
    samples.resize(size / 2);
    
    // Convert bytes to int16_t samples
    for (uint64_t i = 0; i < size; i += 2) {
        int16_t sample = static_cast<int16_t>((data[i+1] << 8) | data[i]);
        samples[i/2] = sample;
    }
}

<%SPL::CodeGen::implementationEpilogue($model);%>