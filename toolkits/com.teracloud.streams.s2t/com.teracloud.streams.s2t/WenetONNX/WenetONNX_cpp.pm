
package WenetONNX_cpp;
use strict; use Cwd 'realpath';  use File::Basename;  use lib dirname(__FILE__);  use SPL::Operator::Instance::OperatorInstance; use SPL::Operator::Instance::Annotation; use SPL::Operator::Instance::Context; use SPL::Operator::Instance::Expression; use SPL::Operator::Instance::ExpressionTree; use SPL::Operator::Instance::ExpressionTreeEvaluator; use SPL::Operator::Instance::ExpressionTreeVisitor; use SPL::Operator::Instance::ExpressionTreeCppGenVisitor; use SPL::Operator::Instance::InputAttribute; use SPL::Operator::Instance::InputPort; use SPL::Operator::Instance::OutputAttribute; use SPL::Operator::Instance::OutputPort; use SPL::Operator::Instance::Parameter; use SPL::Operator::Instance::StateVariable; use SPL::Operator::Instance::TupleValue; use SPL::Operator::Instance::Window; 
sub main::generate($$) {
   my ($xml, $signature) = @_;  
   print "// $$signature\n";
   my $model = SPL::Operator::Instance::OperatorInstance->new($$xml);
   unshift @INC, dirname ($model->getContext()->getOperatorDirectory()) . "/../impl/nl/include";
   $SPL::CodeGenHelper::verboseMode = $model->getContext()->isVerboseModeOn();
   print '/*', "\n";
   print ' * WenetONNX operator implementation', "\n";
   print ' */', "\n";
   print "\n";
   SPL::CodeGen::implementationPrologue($model);
   print "\n";
   print "\n";
       my $encoderModel = $model->getParameterByName("encoderModel")->getValueAt(0)->getCppExpression();
       my $vocabFile = $model->getParameterByName("vocabFile")->getValueAt(0)->getCppExpression();
       my $cmvnFile = $model->getParameterByName("cmvnFile")->getValueAt(0)->getCppExpression();
       
       my $sampleRate = $model->getParameterByName("sampleRate");
       $sampleRate = $sampleRate ? $sampleRate->getValueAt(0)->getCppExpression() : "16000";
       
       my $chunkSizeMs = $model->getParameterByName("chunkSizeMs");
       $chunkSizeMs = $chunkSizeMs ? $chunkSizeMs->getValueAt(0)->getCppExpression() : "100";
       
       my $numThreads = $model->getParameterByName("numThreads");
       $numThreads = $numThreads ? $numThreads->getValueAt(0)->getCppExpression() : "4";
       
       my $provider = $model->getParameterByName("provider");
       my $useGpu = "false";
       if ($provider && $provider->getValueAt(0)->getSPLExpression() ne "CPU") {
           $useGpu = "true";
       }
   print "\n";
   print "\n";
   print '#include "./WenetONNX.h"', "\n";
   print '#include <SPL/Runtime/Common/ApplicationRuntimeMessage.h>', "\n";
   print '#include <SPL/Runtime/Utility/LogTraceMessage.h>', "\n";
   print '#include <iostream>', "\n";
   print '#include <vector>', "\n";
   print "\n";
   print 'using namespace SPL;', "\n";
   print 'using namespace std;', "\n";
   print "\n";
   print 'namespace wenet_onnx_operator {', "\n";
   print "\n";
   print 'MY_OPERATOR_SCOPE::MY_OPERATOR::MY_OPERATOR() ', "\n";
   print '    : initialized_(false)', "\n";
   print '    , audio_timestamp_ms_(0)', "\n";
   print '    , total_samples_processed_(0) {', "\n";
   print '    ', "\n";
   print '    SPLAPPTRC(L_DEBUG, "WenetONNX operator constructor", "WenetONNX");', "\n";
   print '}', "\n";
   print "\n";
   print 'MY_OPERATOR_SCOPE::MY_OPERATOR::~MY_OPERATOR() {', "\n";
   print '    SPLAPPTRC(L_DEBUG, "WenetONNX operator destructor", "WenetONNX");', "\n";
   print '}', "\n";
   print "\n";
   print 'void MY_OPERATOR_SCOPE::MY_OPERATOR::initialize() {', "\n";
   print '    if (initialized_) return;', "\n";
   print '    ', "\n";
   print '    try {', "\n";
   print '        // Configure ONNX implementation', "\n";
   print '        config_.encoder_onnx_path = ';
   print $encoderModel;
   print ';', "\n";
   print '        config_.vocab_path = ';
   print $vocabFile;
   print ';', "\n";
   print '        config_.cmvn_stats_path = ';
   print $cmvnFile;
   print ';', "\n";
   print '        config_.sample_rate = ';
   print $sampleRate;
   print ';', "\n";
   print '        config_.chunk_size_ms = ';
   print $chunkSizeMs;
   print ';', "\n";
   print '        config_.num_threads = ';
   print $numThreads;
   print ';', "\n";
   print '        config_.use_gpu = ';
   print $useGpu;
   print ';', "\n";
   print '        ', "\n";
   print '        SPLAPPTRC(L_INFO, "Initializing WenetONNX with model: " + config_.encoder_onnx_path, "WenetONNX");', "\n";
   print '        ', "\n";
   print '        // Create implementation', "\n";
   print '        wenet_impl_ = std::make_unique<wenet_streams::WenetONNXImpl>(config_);', "\n";
   print '        ', "\n";
   print '        // Initialize', "\n";
   print '        if (!wenet_impl_->initialize()) {', "\n";
   print '            SPLAPPTRC(L_ERROR, "Failed to initialize WenetONNX", "WenetONNX");', "\n";
   print '            throw std::runtime_error("WenetONNX initialization failed");', "\n";
   print '        }', "\n";
   print '        ', "\n";
   print '        initialized_ = true;', "\n";
   print '        SPLAPPTRC(L_INFO, "WenetONNX initialized successfully", "WenetONNX");', "\n";
   print '        ', "\n";
   print '    } catch (const std::exception& e) {', "\n";
   print '        SPLAPPTRC(L_ERROR, "Exception during initialization: " + string(e.what()), "WenetONNX");', "\n";
   print '        throw;', "\n";
   print '    }', "\n";
   print '}', "\n";
   print "\n";
   print 'void MY_OPERATOR_SCOPE::MY_OPERATOR::process(Tuple const & tuple, uint32_t port) {', "\n";
   print '    // Initialize on first tuple', "\n";
   print '    if (!initialized_) {', "\n";
   print '        initialize();', "\n";
   print '    }', "\n";
   print '    ', "\n";
   print '    AutoPortMutex apm(_mutex, *this);', "\n";
   print '    ', "\n";
   print '    const IPort0Type& iport = static_cast<const IPort0Type&>(tuple);', "\n";
   print '    ', "\n";
   print '    // Get audio data - adjust attribute name based on your schema', "\n";
   print '    // Assuming attributes: audio (blob), timestamp (uint64)', "\n";
   print '    if (iport.has_audio()) {', "\n";
   print '        processAudioData(iport.get_audio());', "\n";
   print '    }', "\n";
   print '    ', "\n";
   print '    // Update timestamp if available', "\n";
   print '    if (iport.has_timestamp()) {', "\n";
   print '        audio_timestamp_ms_ = iport.get_timestamp();', "\n";
   print '    }', "\n";
   print '}', "\n";
   print "\n";
   print 'void MY_OPERATOR_SCOPE::MY_OPERATOR::processAudioData(const SPL::blob& audio_blob) {', "\n";
   print '    // Get audio samples', "\n";
   print '    const int16_t* samples = reinterpret_cast<const int16_t*>(audio_blob.getData());', "\n";
   print '    size_t num_samples = audio_blob.getSize() / sizeof(int16_t);', "\n";
   print '    ', "\n";
   print '    if (num_samples == 0) return;', "\n";
   print '    ', "\n";
   print '    // Process with ONNX implementation', "\n";
   print '    auto result = wenet_impl_->processAudioChunk(samples, num_samples, audio_timestamp_ms_);', "\n";
   print '    ', "\n";
   print '    // Update stats', "\n";
   print '    total_samples_processed_ += num_samples;', "\n";
   print '    audio_timestamp_ms_ += (num_samples * 1000) / config_.sample_rate;', "\n";
   print '    ', "\n";
   print '    // Submit result if we have text', "\n";
   print '    if (!result.text.empty()) {', "\n";
   print '        submitResult(result);', "\n";
   print '    }', "\n";
   print '    ', "\n";
   print '    // Log performance periodically', "\n";
   print '    if (total_samples_processed_ % (config_.sample_rate * 10) == 0) {', "\n";
   print '        auto stats = wenet_impl_->getStats();', "\n";
   print '        SPLAPPTRC(L_INFO, ', "\n";
   print '            "Processed " + to_string(total_samples_processed_ / config_.sample_rate) + ', "\n";
   print '            " seconds, RTF: " + to_string(stats.real_time_factor), ', "\n";
   print '            "WenetONNX");', "\n";
   print '    }', "\n";
   print '}', "\n";
   print "\n";
   print 'void MY_OPERATOR_SCOPE::MY_OPERATOR::submitResult(const wenet_streams::WenetONNXImpl::TranscriptionResult& result) {', "\n";
   print '    // Create output tuple', "\n";
   print '    OPort0Type otuple;', "\n";
   print '    ', "\n";
   print '    // Set attributes - adjust based on your output schema', "\n";
   print '    // Assuming: text (rstring), isFinal (boolean), confidence (float64), ', "\n";
   print '    //           timestamp (uint64), latencyMs (uint64)', "\n";
   print '    otuple.set_text(result.text);', "\n";
   print '    otuple.set_isFinal(result.is_final);', "\n";
   print '    otuple.set_confidence(result.confidence);', "\n";
   print '    otuple.set_timestamp(result.timestamp_ms);', "\n";
   print '    otuple.set_latencyMs(result.latency_ms);', "\n";
   print '    ', "\n";
   print '    // Submit the tuple', "\n";
   print '    submit(otuple, 0);', "\n";
   print '    ', "\n";
   print '    SPLAPPTRC(L_DEBUG, ', "\n";
   print '        "Submitted: " + result.text + ', "\n";
   print '        " (final=" + to_string(result.is_final) + ', "\n";
   print '        ", latency=" + to_string(result.latency_ms) + "ms)", ', "\n";
   print '        "WenetONNX");', "\n";
   print '}', "\n";
   print "\n";
   print 'void MY_OPERATOR_SCOPE::MY_OPERATOR::process(Punctuation const & punct, uint32_t port) {', "\n";
   print '    if (punct == Punctuation::FinalMarker) {', "\n";
   print '        // Reset the decoder on final punctuation', "\n";
   print '        if (wenet_impl_) {', "\n";
   print '            wenet_impl_->reset();', "\n";
   print '            SPLAPPTRC(L_DEBUG, "Reset decoder on final punctuation", "WenetONNX");', "\n";
   print '        }', "\n";
   print '    }', "\n";
   print '    ', "\n";
   print '    // Forward punctuation', "\n";
   print '    submit(punct, 0);', "\n";
   print '}', "\n";
   print "\n";
   print '} // namespace wenet_onnx_operator', "\n";
   print "\n";
   SPL::CodeGen::implementationEpilogue($model);
   print "\n";
   CORE::exit $SPL::CodeGen::USER_ERROR if ($SPL::CodeGen::sawError);
}
1;
