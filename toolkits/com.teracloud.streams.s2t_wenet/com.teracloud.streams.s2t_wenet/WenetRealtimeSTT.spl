namespace com.teracloud.streams.s2t_wenet;

/**
 * Real-time Speech-to-Text operator using WeNet
 * 
 * This operator processes audio streams in real-time with minimal latency.
 * It does NOT batch audio - each chunk is processed immediately.
 * 
 * @input AudioIn Audio stream with int16 samples
 * @output TranscriptionOut Transcription results with timing info
 * @param modelPath Path to WeNet model directory
 * @param chunkMs Processing chunk size in milliseconds (default: 100)
 * @param enablePartial Enable partial transcription results (default: true)
 * @param vadSilenceMs Silence duration to end utterance (default: 500)
 */
public composite WenetRealtimeSTT(
    input stream<blob audio, uint64 timestamp> AudioIn;
    output stream<rstring text, boolean isFinal, float64 confidence, 
                  uint64 audioTimestamp, uint64 latencyMs> TranscriptionOut)
{
    param
        expression<rstring> $modelPath;
        expression<int32> $chunkMs : 100;       // Process every 100ms
        expression<boolean> $enablePartial : true;
        expression<int32> $vadSilenceMs : 500;  // 500ms silence = end
        expression<int32> $sampleRate : 16000;
        
    graph
        // Real-time transcription with immediate processing
        stream<TranscriptionOut> TranscriptionOut = Custom(AudioIn) {
            logic
                state: {
                    mutable WenetRealtimeSTT stt = null;
                    mutable boolean initialized = false;
                    mutable uint64 totalSamples = 0;
                    mutable uint64 totalLatency = 0;
                    mutable uint64 resultCount = 0;
                }
                
                onTuple AudioIn: {
                    if (!initialized) {
                        // Initialize on first tuple
                        RealtimeConfig config;
                        config.model_path = $modelPath;
                        config.sample_rate = $sampleRate;
                        config.chunk_ms = $chunkMs;
                        config.enable_partial = $enablePartial;
                        config.vad_silence_ms = $vadSilenceMs;
                        
                        // Create STT engine with callbacks
                        stt = new WenetRealtimeSTT(config,
                            // Result callback
                            [this](const RealtimeResult& result) {
                                // Submit result immediately
                                submit({
                                    text = result.text,
                                    isFinal = result.is_final,
                                    confidence = result.confidence,
                                    audioTimestamp = result.audio_timestamp_ms,
                                    latencyMs = result.latency_ms()
                                }, TranscriptionOut);
                                
                                // Track latency
                                totalLatency += result.latency_ms();
                                resultCount++;
                                
                                if (resultCount % 100 == 0) {
                                    log(Trace, "Avg latency: " + 
                                        (string)(totalLatency / resultCount) + "ms");
                                }
                            },
                            // Error callback
                            [](const string& error) {
                                log(Error, "STT Error: " + error);
                            }
                        );
                        
                        if (!stt->initialize()) {
                            log(Error, "Failed to initialize WeNet STT");
                            return;
                        }
                        
                        initialized = true;
                        log(Info, "WeNet real-time STT initialized");
                    }
                    
                    // Process audio immediately - NO BATCHING!
                    blob audioBlob = AudioIn.audio;
                    int16* samples = (int16*)audioBlob.getData();
                    uint32 numSamples = audioBlob.getSize() / 2; // int16 = 2 bytes
                    
                    // Feed audio with timestamp
                    stt->processAudio(samples, numSamples, AudioIn.timestamp);
                    
                    totalSamples += numSamples;
                    
                    // Log throughput periodically
                    if (totalSamples % ($sampleRate * 10) == 0) { // Every 10 seconds
                        log(Trace, "Processed " + (string)(totalSamples / $sampleRate) + 
                                  " seconds of audio");
                    }
                }
                
                onPunct AudioIn: {
                    if (currentPunct() == Sys.FinalMarker) {
                        if (initialized && stt != null) {
                            // Process any remaining audio
                            stt->endStream();
                            
                            // Get final stats
                            auto stats = stt->getLatencyStats();
                            log(Info, "Final latency stats - Avg: " + 
                                     (string)stats.avg_latency_ms + "ms, " +
                                     "Min: " + (string)stats.min_latency_ms + "ms, " +
                                     "Max: " + (string)stats.max_latency_ms + "ms");
                            
                            delete stt;
                        }
                    }
                }
        }
}